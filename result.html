
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>diceroller: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/skyestalimit/diceroller/diceRoller.go (100.0%)</option>
				
				<option value="file1">github.com/skyestalimit/diceroller/diceroll.go (100.0%)</option>
				
				<option value="file2">github.com/skyestalimit/diceroller/dicerollresult.go (97.8%)</option>
				
				<option value="file3">github.com/skyestalimit/diceroller/rollargparser.go (100.0%)</option>
				
				<option value="file4">github.com/skyestalimit/diceroller/rollattributes.go (100.0%)</option>
				
				<option value="file5">github.com/skyestalimit/diceroller/rollingexpression.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package diceroller generates either a sum or DiceRollResults out of
// RollArgs or DiceRolls. It's just that simple so get rolling!
package diceroller

import (
        "math"
        "math/rand"
        "slices"
)

type DiceRollAttribs struct {
        diceAmmount int
        advDis      rollAttribute
        dropHigh    rollAttribute
        dropLow     rollAttribute
        half        rollAttribute
}

// Straightforward rolling using RollArgs. Returns the sum, invalid RollArgs are worth 0.
func PerformRollArgsAndSum(rollArgs ...string) int <span class="cov8" title="1">{
        rollExprs, _ := ParseRollArgs(rollArgs...)
        return performRollingExpressionsAndSum(rollExprs...)
}</span>

// Performs an array of RollArgs. Returns a DiceRollResult array for valid RollArgs and an error array for invalid ones.
func PerformRollArgs(rollArgs ...string) ([]RollingExpressionResult, []error) <span class="cov8" title="1">{
        rollExprs, argErrs := ParseRollArgs(rollArgs...)
        results, diceErrs := performRollingExpressions(rollExprs...)
        return results, append(argErrs, diceErrs...)
}</span>

// Performs an array of DiceRoll. Returns the sum, invalid DiceRolls are worth 0.
func PerformRollsAndSum(diceRolls ...DiceRoll) int <span class="cov8" title="1">{
        results, _ := PerformRolls(diceRolls...)
        return DiceRollResultsSum(results...)
}</span>

// Performs an array of DiceRoll. Returns a DiceRollResult array for valid DiceRolls and an error array for invalid ones.
func PerformRolls(diceRolls ...DiceRoll) (results []DiceRollResult, diceErrs []error) <span class="cov8" title="1">{
        for i := range diceRolls </span><span class="cov8" title="1">{
                if result, diceErr := performRoll(diceRolls[i]); diceErr == nil </span><span class="cov8" title="1">{
                        results = append(results, *result)
                }</span> else<span class="cov8" title="1"> {
                        diceErrs = append(diceErrs, diceErr)
                }</span>
        }
        <span class="cov8" title="1">return results, diceErrs</span>
}

// Performs a rolling expression. Returns the sum, invalid DiceRolls are worth 0.
func performRollingExpressionsAndSum(rollExprs ...rollingExpression) int <span class="cov8" title="1">{
        results, _ := performRollingExpressions(rollExprs...)
        return RollingExpressionResultSum(results...)
}</span>

// Performs a rolling expression. Returns a DiceRollResult array for valid DiceRolls and an error array for invalid ones.
func performRollingExpressions(rollExprs ...rollingExpression) (results []RollingExpressionResult, diceErrs []error) <span class="cov8" title="1">{
        wasCritHit := false
        for e := range rollExprs </span><span class="cov8" title="1">{
                rollExprResult := newRollingExpressionResult()
                for i := range rollExprs[e].diceRolls </span><span class="cov8" title="1">{
                        diceRoll := rollExprs[e].diceRolls[i]
                        if wasCritHit &amp;&amp; diceRoll.Attribs.hasAttrib(dmgAttrib) </span><span class="cov8" title="1">{
                                diceRoll.Attribs.setRollAttrib(critAttrib)
                        }</span>
                        <span class="cov8" title="1">if result, diceErr := performRoll(diceRoll); diceErr == nil </span><span class="cov8" title="1">{
                                rollExprResult.Results = append(rollExprResult.Results, *result)
                                rollExprResult.Sum += result.Sum
                        }</span> else<span class="cov8" title="1"> {
                                diceErrs = append(diceErrs, diceErr)
                        }</span>
                }

                <span class="cov8" title="1">wasCritHit = rollExprResult.detectCritHit()

                results = append(results, *rollExprResult)</span>
        }
        <span class="cov8" title="1">return results, diceErrs</span>
}

// Validates and performs diceRoll. Returns a DiceRollResult if valid, an error if invalid.
func performRoll(diceRoll DiceRoll) (*DiceRollResult, error) <span class="cov8" title="1">{
        // Validate DiceRoll
        if diceErr := validateDiceRoll(diceRoll); diceErr != nil </span><span class="cov8" title="1">{
                // Invalid DiceRoll, return error
                return nil, diceErr
        }</span>

        // Valid DiceRoll. Generate and return DiceRollResult
        <span class="cov8" title="1">return generateRolls(diceRoll), nil</span>
}

// Generates DiceRollResult and applies attribs.
func generateRolls(diceRoll DiceRoll) *DiceRollResult <span class="cov8" title="1">{
        diceRollResult := newDiceRollResult(diceRoll)
        diceRollAttribs := prepareDiceRollAttribs(diceRoll)

        // Generate rolls
        for i := 0; i &lt; diceRollAttribs.diceAmmount; i++ </span><span class="cov8" title="1">{
                roll := rollDice(diceRoll.DiceSize)

                // Advantage / disadvantage attrib
                if diceRollAttribs.advDis &gt; 0 </span><span class="cov8" title="1">{
                        roll = advantageDisadvantage(diceRollAttribs.advDis, roll, rollDice(diceRoll.DiceSize), diceRollResult)
                }</span>

                <span class="cov8" title="1">diceRollResult.Dice = append(diceRollResult.Dice, roll)
                diceRollResult.Sum += roll</span>
        }

        // Drop High attrib
        <span class="cov8" title="1">if diceRollAttribs.dropHigh &gt; 0 &amp;&amp; len(diceRollResult.Dice) &gt; 1 </span><span class="cov8" title="1">{
                dropHighLow(diceRollAttribs.dropHigh, diceRollResult)
        }</span>

        // Drop Low attrib
        <span class="cov8" title="1">if diceRollAttribs.dropLow &gt; 0 &amp;&amp; len(diceRollResult.Dice) &gt; 1 </span><span class="cov8" title="1">{
                dropHighLow(diceRollAttribs.dropLow, diceRollResult)
        }</span>

        // Apply modifier
        <span class="cov8" title="1">diceRollResult.Sum += diceRoll.Modifier

        // Half attrib
        if diceRollAttribs.half == halfAttrib </span><span class="cov8" title="1">{
                diceRollResult.Sum = halve(diceRollResult.Sum)
        }</span>

        // Minimum roll result is always 1, even after applying negative modifiers
        <span class="cov8" title="1">if diceRollResult.Sum &lt;= 0 </span><span class="cov8" title="1">{
                diceRollResult.Sum = 1
        }</span>

        // Negative Sum if minus DiceRoll
        <span class="cov8" title="1">if !diceRoll.Plus </span><span class="cov8" title="1">{
                diceRollResult.Sum = -diceRollResult.Sum
        }</span>

        <span class="cov8" title="1">return diceRollResult</span>
}

// Generates a single die roll.
func rollDice(diceSize int) int <span class="cov8" title="1">{
        return rand.Intn(diceSize) + 1
}</span>

func prepareDiceRollAttribs(diceRoll DiceRoll) DiceRollAttribs <span class="cov8" title="1">{

        dndRollAttributes, _ := diceRoll.Attribs.(*dndRollAttributes)

        // Setup according to attribs
        diceRollAttribs := DiceRollAttribs{diceRoll.DiceAmmount, 0, 0, 0, 0}

        if dndRollAttributes != nil </span><span class="cov8" title="1">{
                for attrib := range dndRollAttributes.attribs </span><span class="cov8" title="1">{
                        switch attrib </span>{
                        case critAttrib:<span class="cov8" title="1">
                                // Crit attrib
                                diceRollAttribs.diceAmmount = diceRollAttribs.diceAmmount * 2</span>
                        case advantageAttrib:<span class="cov8" title="1">
                                diceRollAttribs.advDis = advantageAttrib</span>
                        case disadvantageAttrib:<span class="cov8" title="1">
                                diceRollAttribs.advDis = disadvantageAttrib</span>
                        case dropHighAttrib:<span class="cov8" title="1">
                                diceRollAttribs.dropHigh = dropHighAttrib</span>
                        case dropLowAttrib:<span class="cov8" title="1">
                                diceRollAttribs.dropLow = dropLowAttrib</span>
                        case halfAttrib:<span class="cov8" title="1">
                                diceRollAttribs.half = halfAttrib</span>
                        }
                }
        }

        <span class="cov8" title="1">return diceRollAttribs</span>
}

// Applies advantage or disavantage logic. Returns the roll to keep and the roll to drop.
func advantageDisadvantage(attrib rollAttribute, roll int, roll2 int, diceRollResult *DiceRollResult) (toKeep int) <span class="cov8" title="1">{
        toKeep, toDrop := roll, roll2 // Default return order, change if needed

        switch attrib </span>{
        case advantageAttrib:<span class="cov8" title="1">
                if roll != max(roll, roll2) </span><span class="cov8" title="1">{
                        toKeep, toDrop = roll2, roll
                }</span>
        case disadvantageAttrib:<span class="cov8" title="1">
                if roll != min(roll, roll2) </span><span class="cov8" title="1">{
                        toKeep, toDrop = roll2, roll
                }</span>
        }

        <span class="cov8" title="1">diceRollResult.AdvDisDropped = append(diceRollResult.AdvDisDropped, toDrop)

        return toKeep</span>
}

// Applies drop high or drop low logic. Returns the index of the roll to drop.
func dropHighLow(attrib rollAttribute, diceRollResult *DiceRollResult) <span class="cov8" title="1">{
        drop := 0

        switch attrib </span>{
        case dropLowAttrib:<span class="cov8" title="1">
                drop = slices.Min(diceRollResult.Dice)</span>
        case dropHighAttrib:<span class="cov8" title="1">
                drop = slices.Max(diceRollResult.Dice)</span>
        }

        <span class="cov8" title="1">dropIndex := slices.Index(diceRollResult.Dice, drop)

        switch attrib </span>{
        case dropLowAttrib:<span class="cov8" title="1">
                diceRollResult.LowDropped = append(diceRollResult.LowDropped, diceRollResult.Dice[dropIndex])</span>
        case dropHighAttrib:<span class="cov8" title="1">
                diceRollResult.HighDropped = append(diceRollResult.HighDropped, diceRollResult.Dice[dropIndex])</span>
        }

        <span class="cov8" title="1">diceRollResult.Sum -= diceRollResult.Dice[dropIndex]
        diceRollResult.Dice = slices.Delete(diceRollResult.Dice, dropIndex, dropIndex+1)</span>
}

// Applies half logic. Rounds down.
func halve(sum int) int <span class="cov8" title="1">{
        halved := 0
        minus := false

        if sum &lt; 0 </span><span class="cov8" title="1">{
                minus = true
        }</span>

        <span class="cov8" title="1">halved = int(math.Abs(float64(sum))) / 2

        // Minimum result is 1 even if rounded down to 0
        if halved &lt; 1 </span><span class="cov8" title="1">{
                halved = 1
        }</span>

        <span class="cov8" title="1">if minus </span><span class="cov8" title="1">{
                halved = -halved
        }</span>

        <span class="cov8" title="1">return halved</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package diceroller

import (
        "fmt"
        "math"
)

// A DiceRoll represents a dice rolling expression, such as 1d6 or 2d8+1.
type DiceRoll struct {
        DiceAmmount int        // Ammount of dice to be rolled
        DiceSize    int        // Size, or number of faces, of the dice to be rolled
        Modifier    int        // Value to be applied to the sum of rolled dices
        Plus        bool       // Determines if the result of the roll is to be added or substracted
        Attribs     attributes // Contains rollAttributes affecting the rolls
}

// Max allowed DiceRoll values to avoid long run times and overflow.
const maxDiceRollValue int = 99999

// Ridiculous error message for ridiculously big values.
const bigNumberErrorMsg = "This is a dice roller, not a Pi calculator"

// DiceRoll constructor, validates values.
func NewDiceRoll(diceAmmount int, diceSize int, modifier int, plus bool) (*DiceRoll, error) <span class="cov8" title="1">{
        return NewDiceRollWithAttribs(diceAmmount, diceSize, modifier, plus, nil)
}</span>

// DiceRoll constructor with rollAttributes, validates values.
func NewDiceRollWithAttribs(diceAmmount int, diceSize int, modifier int, plus bool, attribs attributes) (*DiceRoll, error) <span class="cov8" title="1">{
        diceRoll := DiceRoll{diceAmmount, diceSize, modifier, plus, attribs}
        if diceErr := validateDiceRoll(diceRoll); diceErr != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid DiceRoll %s", diceErr.Error())
        }</span>
        <span class="cov8" title="1">return &amp;diceRoll, nil</span>
}

// DiceRoll constructor without errors.
func newDiceRoll(diceAmmount int, diceSize int, modifier int, plus bool) *DiceRoll <span class="cov8" title="1">{
        diceRoll, _ := NewDiceRollWithAttribs(diceAmmount, diceSize, modifier, plus, nil)
        return diceRoll
}</span>

// Performs the DiceRoll. Returns the sum if valid, zero if invalid.
func (diceRoll DiceRoll) Roll() int <span class="cov8" title="1">{
        result, _ := performRoll(diceRoll)
        return result.Sum
}</span>

// Human readable DiceRoll string, such as "2d8+1".
func (diceRoll DiceRoll) String() string <span class="cov8" title="1">{
        strDiceRoll := ""

        // Add minus symbol if needed
        if !diceRoll.Plus </span><span class="cov8" title="1">{
                strDiceRoll += "-"
        }</span>

        // XdY format
        <span class="cov8" title="1">strDiceRoll += fmt.Sprintf("%dd%d", diceRoll.DiceAmmount, diceRoll.DiceSize)

        // Add modifier when necessary
        if diceRoll.Modifier != 0 </span><span class="cov8" title="1">{
                if diceRoll.Modifier &gt; 0 </span><span class="cov8" title="1">{
                        strDiceRoll += "+"
                }</span>
                <span class="cov8" title="1">strDiceRoll += fmt.Sprint(diceRoll.Modifier)</span>
        }

        <span class="cov8" title="1">return strDiceRoll</span>
}

// Validates diceRoll values. Returns nil if valid, error if invalid.
func validateDiceRoll(diceRoll DiceRoll) error <span class="cov8" title="1">{
        if diceErr := validateDiceAmmout(diceRoll.DiceAmmount); diceErr != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("%s: %s", diceRoll.String(), diceErr.Error())
        }</span>
        <span class="cov8" title="1">if diceErr := validateDiceSize(diceRoll.DiceSize); diceErr != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("%s: %s", diceRoll.String(), diceErr.Error())
        }</span>
        <span class="cov8" title="1">if diceErr := validateDiceModifier(diceRoll.Modifier); diceErr != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("%s: %s", diceRoll.String(), diceErr.Error())
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Validates diceAmmount values for DiceRoll. Returns nil if valid, an error if invalid.
func validateDiceAmmout(diceAmmount int) error <span class="cov8" title="1">{
        ammountErrStr := "invalid dice ammout"
        if diceAmmount &gt; maxDiceRollValue </span><span class="cov8" title="1">{
                return fmt.Errorf("%s %d. %s", ammountErrStr, diceAmmount, bigNumberErrorMsg)
        }</span> else<span class="cov8" title="1"> if diceAmmount &lt;= 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("%s %d", ammountErrStr, diceAmmount)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Validates diceSize values for DiceRoll. Returns nil if valid, an error if invalid.
func validateDiceSize(diceSize int) error <span class="cov8" title="1">{
        sizeErrStr := "invalid dice size"
        if diceSize &gt; maxDiceRollValue </span><span class="cov8" title="1">{
                return fmt.Errorf("%s %d. %s", sizeErrStr, diceSize, bigNumberErrorMsg)
        }</span> else<span class="cov8" title="1"> if diceSize &lt;= 1 </span><span class="cov8" title="1">{
                return fmt.Errorf("%s %d", sizeErrStr, diceSize)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Validates modifier values for DiceRoll. Returns nil if valid, an error if invalid.
func validateDiceModifier(modifier int) error <span class="cov8" title="1">{
        if int(math.Abs(float64(modifier))) &gt; maxDiceRollValue </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid dice modifier %d. %s", modifier, bigNumberErrorMsg)
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package diceroller

import (
        "fmt"
        "sort"
)

// A DiceRollResult contains the results of performing a DiceRoll
type DiceRollResult struct {
        diceRoll      DiceRoll // Performed DiceRoll
        Dice          []int    // Individual dice roll result
        Sum           int      // Sum of Dice
        AdvDisDropped []int    // Dropped advantage/disadvantage dice
        HighDropped   []int    // Dropped high dice
        LowDropped    []int    // Dropped low dice
}

// DiceRollResult constructor with DiceRoll readable string and rollAttributes.
func newDiceRollResult(diceRoll DiceRoll) *DiceRollResult <span class="cov8" title="1">{
        return &amp;DiceRollResult{diceRoll, []int{}, 0, []int{}, []int{}, []int{}}
}</span>

// Returns the total sum of a DiceRollResult array.
func DiceRollResultsSum(results ...DiceRollResult) (sum int) <span class="cov8" title="1">{
        for i := range results </span><span class="cov8" title="1">{
                sum += results[i].Sum
        }</span>

        // Minimum DiceRoll result is 1, if at least a die was rolled
        <span class="cov8" title="1">if len(results) &gt; 0 &amp;&amp; sum &lt; 1 </span><span class="cov0" title="0">{
                sum = 1
        }</span>
        <span class="cov8" title="1">return</span>
}

// Human readable DiceRollResult string.
func (result DiceRollResult) String() string <span class="cov8" title="1">{
        resultStr := " Result of DiceRoll \""
        var advDis rollAttribute = 0
        spell := false

        // Start with roll attributes
        if result.diceRoll.Attribs != nil </span><span class="cov8" title="1">{
                rollAttribsMap := result.diceRoll.Attribs.(*dndRollAttributes)
                // Sort the attributes
                attribs := make([]rollAttribute, 0, len(rollAttribsMap.attribs))
                for rollAttrib := range rollAttribsMap.attribs </span><span class="cov8" title="1">{
                        attribs = append(attribs, rollAttrib)
                }</span>
                <span class="cov8" title="1">sort.SliceStable(attribs, func(i int, j int) bool </span><span class="cov8" title="1">{
                        return attribs[i] &lt; attribs[j]
                }</span>)

                // Add them to the result string
                <span class="cov8" title="1">for i := range attribs </span><span class="cov8" title="1">{
                        rollAttrib := rollAttribute(attribs[i])
                        switch rollAttrib </span>{
                        case advantageAttrib:<span class="cov8" title="1">
                                advDis = advantageAttrib</span>
                        case disadvantageAttrib:<span class="cov8" title="1">
                                advDis = disadvantageAttrib</span>
                        case spellAttrib:<span class="cov8" title="1">
                                spell = true</span>
                        }
                        <span class="cov8" title="1">resultStr += fmt.Sprintf("%s ", rollAttributeMap[rollAttrib])</span>
                }
        }

        // DiceRoll string and dice result array
        <span class="cov8" title="1">resultStr += fmt.Sprintf("%s\": \n  Rolls:     %s\n", result.diceRoll, fmt.Sprint(result.Dice))

        // Advantage / disadvantage dropped dice array
        if len(result.AdvDisDropped) &gt; 0 </span><span class="cov8" title="1">{
                advDisStr := ""
                switch advDis </span>{
                case advantageAttrib:<span class="cov8" title="1">
                        advDisStr = "Adv drop:"</span>
                case disadvantageAttrib:<span class="cov8" title="1">
                        advDisStr = "Dis drop:"</span>
                }

                <span class="cov8" title="1">resultStr += fmt.Sprintf("  %s  %s\n", advDisStr, fmt.Sprint(result.AdvDisDropped))</span>
        }

        // Dropped High dice array
        <span class="cov8" title="1">if len(result.HighDropped) &gt; 0 </span><span class="cov8" title="1">{
                resultStr += fmt.Sprintf("  Drop High: %s\n", fmt.Sprint(result.HighDropped))
        }</span>

        // Dropped Low dice array
        <span class="cov8" title="1">if len(result.LowDropped) &gt; 0 </span><span class="cov8" title="1">{
                resultStr += fmt.Sprintf("  Drop Low:  %s\n", fmt.Sprint(result.LowDropped))
        }</span>

        // The DiceRoll sum
        <span class="cov8" title="1">resultStr += fmt.Sprintf("  Sum:       %d", result.Sum)

        // Half ammount for passing a spell saving throw
        if spell </span><span class="cov8" title="1">{
                resultStr += fmt.Sprintf(" Saved: %d", halve(result.Sum))
        }</span>

        <span class="cov8" title="1">resultStr += "\n"

        return resultStr</span>
}

// Detects a critical hit.
func (rollResult DiceRollResult) isCritHit() bool <span class="cov8" title="1">{
        critHit := false

        if len(rollResult.Dice) == 1 &amp;&amp; rollResult.Dice[0] == 20 &amp;&amp;
                rollResult.diceRoll.DiceAmmount == 1 &amp;&amp; rollResult.diceRoll.DiceSize == 20 </span><span class="cov8" title="1">{
                critHit = true
        }</span>

        <span class="cov8" title="1">if critHit </span><span class="cov8" title="1">{
                fmt.Printf("is crit hit : %s", rollResult)

        }</span>

        <span class="cov8" title="1">return critHit</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package diceroller

import (
        "fmt"
        "regexp"
        "strconv"
        "strings"
)

// RollArg regex
const rollArgFormat string = `^([+-])?(\d+)?[dD](\d+)([+-](\d+))?$`

// Attributes regex
const rollAttribsFormat string = `^[a-z]+$`

// Maximum allowed RollArg length
const maxAllowedRollArgLength int = 5

// Parses a RollArg array. Returns a DiceRoll array for valid RollArgs, an
// error array for invalid ones.
//
// A valid RollArg matches either the DiceRoll format or a rollAttribute string.
//
// DiceRoll format: [X]dY[+|-]Z. In other words XdY or dY followed by + or - Z.
// Valid DiceRoll examples: "5d6", "d20", "4d4+1", "10d10", "1d6-1", "1D8".
//
// RollArgs will be converted into DiceRolls and grouped together in rolling
// expressions. A new rolling expression starts when a rollAttribute is
// parsed after a sequence of DiceRolls.
//
// For example:
//   - 5d6 1d6 10d10 would return one rolling expression containing all three
//     RollArgs as DiceRolls.
//   - adv d20+5 half spell 8d8 would return two rolling expressions: "adv 1d20+5"
//     and "half spell 8d8".
//   - 5d6 roll 4d6 roll 3d6 would return three rolling expressions: "5d6", "4d6" and "3d6".
//
// rollAttribute string list:
//   - roll, hit, dmg : separators, starts a new rolling expressions
//
// DnD rollAttribute string list:
//   - crit: Critical, doubles all dice ammount
//   - spell: Spell, DiceRollResults.String() prints the sum and the sum halved for saves
//   - half: Halves the sums, for resistances and such
//   - adv: Advantage, rolls each dice twice and drops the lowest
//   - dis: Disadvantage, rolls each dice twice and drops the highest
//   - drophigh: Drop High, drops the highest result of a DiceRoll
//   - droplow: Drop Low, drops the lowest result of a DiceRoll
func ParseRollArgs(rollArgs ...string) (rollingExpressions []rollingExpression, errors []error) <span class="cov8" title="1">{
        // We're building rollingExpressions along with their rollAttributes
        rollExpr := newRollingExpression()
        attribs := newDnDRollAttributes()
        diceRollSequence := false

        for i := range rollArgs </span><span class="cov8" title="1">{
                if rollAttrib := checkForRollAttribute(rollArgs[i]); rollAttrib != 0 </span><span class="cov8" title="1">{
                        // Start a new rolling expression after a dice roll sequence ends
                        if diceRollSequence </span><span class="cov8" title="1">{
                                if len(rollExpr.diceRolls) &gt; 0 </span><span class="cov8" title="1">{
                                        //
                                        rollingExpressions = append(rollingExpressions, *rollExpr)
                                        rollExpr = newRollingExpression()
                                        attribs = newDnDRollAttributes()
                                }</span>
                        }
                        <span class="cov8" title="1">attribs.setRollAttrib(rollAttrib)
                        diceRollSequence = false</span>
                } else<span class="cov8" title="1"> if diceRoll, err := parseRollArg(rollArgs[i]); err == nil </span><span class="cov8" title="1">{
                        diceRoll.Attribs = attribs
                        rollExpr.diceRolls = append(rollExpr.diceRolls, *diceRoll)
                        diceRollSequence = true
                }</span> else<span class="cov8" title="1"> {
                        errors = append(errors, err)
                }</span>
        }

        <span class="cov8" title="1">rollingExpressions = append(rollingExpressions, *rollExpr)

        return</span>
}

// Checks if the rollArg is a rollAttribute. Returns the rollAttribute value if it matches, otherwise zero.
func checkForRollAttribute(rollArg string) rollAttribute <span class="cov8" title="1">{
        var rollAttrib rollAttribute = 0
        attribRegEx := regexp.MustCompile(rollAttribsFormat)
        if attribRegEx.MatchString(strings.ToLower(rollArg)) </span><span class="cov8" title="1">{
                rollAttrib = rollAttributeMapKey(rollAttributeMap, rollArg)
        }</span>
        <span class="cov8" title="1">return rollAttrib</span>
}

// Parses rollArg. Returns a DiceRoll if valid, an error if invalid.
func parseRollArg(rollArg string) (*DiceRoll, error) <span class="cov8" title="1">{
        // Validate rollArg format
        rollArgregex := regexp.MustCompile(rollArgFormat)
        if !rollArgregex.MatchString(rollArg) </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid RollArg: %s", rollArg)
        }</span>

        // Parse rollArg into slices using the regex matches
        <span class="cov8" title="1">matches := rollArgregex.FindStringSubmatch(rollArg)

        var diceAmmount, diceSize, modifier = 0, 0, 0
        plus := true

        // Parse minus sign
        if len(matches[1]) &gt; 0 </span><span class="cov8" title="1">{
                if strings.EqualFold(matches[1], "-") </span><span class="cov8" title="1">{
                        plus = false
                }</span>
        }

        // Parse dice ammount
        <span class="cov8" title="1">if len(matches[2]) &gt; 0 </span><span class="cov8" title="1">{
                if value, argErr := parseRollArgSlice(matches[2]); argErr == nil </span><span class="cov8" title="1">{
                        diceAmmount = value
                }</span> else<span class="cov8" title="1"> {
                        return nil, argErr
                }</span>
        } else<span class="cov8" title="1"> {
                // dY syntax.
                diceAmmount = 1
        }</span>

        // Parse dice size
        <span class="cov8" title="1">if value, argErr := parseRollArgSlice(matches[3]); argErr == nil </span><span class="cov8" title="1">{
                diceSize = value
        }</span> else<span class="cov8" title="1"> {
                return nil, argErr
        }</span>

        // Parse modifier
        <span class="cov8" title="1">if len(matches[4]) &gt; 0 </span><span class="cov8" title="1">{
                if value, argErr := parseRollArgSlice(matches[4]); argErr == nil </span><span class="cov8" title="1">{
                        modifier = value
                }</span> else<span class="cov8" title="1"> {
                        return nil, argErr
                }</span>
        }

        <span class="cov8" title="1">return NewDiceRoll(diceAmmount, diceSize, modifier, plus)</span>
}

// Parses a rollArg slice. Returns its value if valid, zero and an error if invalid.
func parseRollArgSlice(rollArgSlice string) (int, error) <span class="cov8" title="1">{
        // Validate rollArgSlice size, max allowed is 5 not including minus symbol
        maxAllowedLength := maxAllowedRollArgLength
        if strings.ContainsAny(rollArgSlice, "-") </span><span class="cov8" title="1">{
                maxAllowedLength++
        }</span>

        <span class="cov8" title="1">if len(rollArgSlice) &gt; maxAllowedLength </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("invalid value: %s. %s", rollArgSlice, bigNumberErrorMsg)
        }</span>

        // Parse rollArgSlice
        <span class="cov8" title="1">return strconv.Atoi(rollArgSlice)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package diceroller

import "strings"

type rollAttribute int

// rollAttribute values. 0 is invalid.
const (
        rollAttrib rollAttribute = iota + 1
        // DnD rollAttribute
        hitAttrib          rollAttribute = iota + 1
        dmgAttrib          rollAttribute = iota + 1
        critAttrib         rollAttribute = iota + 1
        spellAttrib        rollAttribute = iota + 1
        halfAttrib         rollAttribute = iota + 1
        advantageAttrib    rollAttribute = iota + 1
        disadvantageAttrib rollAttribute = iota + 1
        dropHighAttrib     rollAttribute = iota + 1
        dropLowAttrib      rollAttribute = iota + 1
)

// Allowed rollAttribute string as RollArg.
const (
        rollStr string = "roll"
        // DnD rollAttribute strings
        hitStr          string = "hit"
        dmgStr          string = "dmg"
        critStr         string = "crit"
        spellStr        string = "spell"
        halfStr         string = "half"
        advantageStr    string = "adv"
        disadvantageStr string = "dis"
        dropHighStr     string = "drophigh"
        dropLowStr      string = "droplow"
)

var rollAttributeMap = map[rollAttribute]string{
        rollAttrib: rollStr,
        // DnD rollAttribute map
        hitAttrib:          hitStr,
        dmgAttrib:          dmgStr,
        critAttrib:         critStr,
        spellAttrib:        spellStr,
        halfAttrib:         halfStr,
        advantageAttrib:    advantageStr,
        disadvantageAttrib: disadvantageStr,
        dropHighAttrib:     dropHighStr,
        dropLowAttrib:      dropLowStr,
}

type attributes interface {
        setRollAttrib(rollAttribute)
        hasAttrib(rollAttribute) bool
}

type dndRollAttributes struct {
        attribs map[rollAttribute]bool
}

// Constructor for rollAttributes.
func newDnDRollAttributes() *dndRollAttributes <span class="cov8" title="1">{
        newDnDRollAttributes := new(dndRollAttributes)
        newDnDRollAttributes.attribs = make(map[rollAttribute]bool)
        return newDnDRollAttributes
}</span>

// To retrieve the roleAttribute matching wanted roleAttribute string.
func rollAttributeMapKey(attribMap map[rollAttribute]string, wanted string) rollAttribute <span class="cov8" title="1">{
        for attrib, attribStr := range attribMap </span><span class="cov8" title="1">{
                if strings.EqualFold(attribStr, wanted) </span><span class="cov8" title="1">{
                        return attrib
                }</span>
        }
        <span class="cov8" title="1">return 0</span>
}

// Sets attrib to true and prevents rollAttribute incompatibilities.
func (dndAttribs dndRollAttributes) setRollAttrib(attrib rollAttribute) <span class="cov8" title="1">{
        switch attrib </span>{
        case advantageAttrib:<span class="cov8" title="1">
                delete(dndAttribs.attribs, disadvantageAttrib)</span>
        case disadvantageAttrib:<span class="cov8" title="1">
                delete(dndAttribs.attribs, advantageAttrib)</span>
        }
        <span class="cov8" title="1">dndAttribs.attribs[attrib] = true</span>
}

// Returns true if wanted is set.
func (dndAttrib dndRollAttributes) hasAttrib(wanted rollAttribute) bool <span class="cov8" title="1">{
        return dndAttrib.attribs[wanted]
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package diceroller

import "fmt"

// Represents a sequence of DiceRolls.
type rollingExpression struct {
        diceRolls []DiceRoll
}

// Results of performing a rollingExpression.
type RollingExpressionResult struct {
        Results []DiceRollResult
        Sum     int
}

// Constructor of rollingExpression.
func newRollingExpression() *rollingExpression <span class="cov8" title="1">{
        rollExpr := new(rollingExpression)
        rollExpr.diceRolls = make([]DiceRoll, 0)
        return rollExpr
}</span>

// Constructor of RollingExpressionResult.
func newRollingExpressionResult() *RollingExpressionResult <span class="cov8" title="1">{
        rollExpr := new(RollingExpressionResult)
        rollExpr.Sum = 0
        rollExpr.Results = make([]DiceRollResult, 0)
        return rollExpr
}</span>

// Sums multiple RollingExpressionResult.
func RollingExpressionResultSum(results ...RollingExpressionResult) (sum int) <span class="cov8" title="1">{
        for i := range results </span><span class="cov8" title="1">{
                sum += results[i].Sum
        }</span>
        <span class="cov8" title="1">return</span>
}

// Formatted result output.
func (rollExpr RollingExpressionResult) String() string <span class="cov8" title="1">{
        resultStr := "Rolling expression\n"
        for i := range rollExpr.Results </span><span class="cov8" title="1">{
                resultStr += rollExpr.Results[i].String()
        }</span>
        <span class="cov8" title="1">resultStr += fmt.Sprintf("\nRoll sum: %d \n", DiceRollResultsSum(rollExpr.Results...))
        return resultStr</span>
}

// Detects a critical hit.
func (rollExprResult RollingExpressionResult) detectCritHit() bool <span class="cov8" title="1">{
        critHit := false
        for i := range rollExprResult.Results </span><span class="cov8" title="1">{
                result := rollExprResult.Results[i]

                if result.isCritHit() </span><span class="cov8" title="1">{
                        critHit = true
                        break</span>
                }
        }
        <span class="cov8" title="1">return critHit</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
